Question: 
Can zkLogin also sign PTB prepared by facilitator. I ask because I am wondering if the buyer on sui can run the full x402 flow without a wallet ... only with zklogin? Explain. How sure are you?
How exactly does Enoki help and is used? Not all technical details but mental model to understand. Any constraint on buyer in addition to zkLogin?

Answer:
### Short answer

**Yes.** A buyer on **Sui** can execute the *entire* x402 flow **without a traditional wallet**, using **zkLogin only**, *including signing a PTB that was prepared by a facilitator*.
This is not theoretical; it is exactly how zkLogin was designed to be used.
**Confidence level:** high (≈90%), with a few clearly defined constraints.

---

## 1. Can zkLogin sign a PTB prepared by a facilitator?

**Yes.** zkLogin can sign **any valid Sui transaction**, including a **Programmable Transaction Block (PTB)**, regardless of who constructed it.

### Why this works

On Sui, there is a strict separation between:

* **Transaction construction** (PTB assembly)
* **Transaction authorization** (signature)

zkLogin replaces *how the signature is produced*, not *what is being signed*.

Concretely:

1. Facilitator constructs a PTB:

   * Move calls
   * Object inputs
   * Coins
   * Gas budget
2. PTB bytes are sent to the buyer (e.g. over HTTPS).
3. Buyer:

   * Authenticates via zkLogin (Google / OAuth)
   * Produces a **zkLogin signature over the PTB digest**
4. Transaction is submitted on-chain.

From the Sui validator’s perspective:

> “This is just a valid signature from a valid Sui address.”

There is **no notion of “who prepared the PTB”** at the protocol level.

---

## 2. Can the buyer run the full x402 flow without a wallet?

**Yes — if you define “wallet” as browser extension / key custody UX.**

The buyer needs **no private key**, no seed phrase, no extension.

### What the buyer *does* need

| Requirement  | Provided by                     |
| ------------ | ------------------------------- |
| Identity     | OAuth provider (Google, etc.)   |
| Signature    | zkLogin                         |
| Gas payment  | Sponsor / facilitator           |
| Coin objects | Created or managed via protocol |
| UX           | Your app + Enoki                |

So the buyer experience is closer to:

> “Sign in with Google → approve payment”

not:

> “Install wallet → manage keys → sign transaction”.

This is exactly the Web2 → Web3 bridge zkLogin targets.

---

## 3. Mental model of zkLogin (important)

Think of zkLogin as:

> **“Ephemeral smart-wallet authorization backed by a ZK proof of Web2 identity.”**

Key properties:

* No long-term private key stored by the user
* Address is *deterministically derived* from:

  * OAuth identity
  * Issuer
  * Salt
* Signature proves:

  * “The user authenticated with issuer X”
  * “The transaction digest is approved”
* Validators verify the ZK proof + signature like any other auth

Crucially:

* zkLogin **does not limit transaction expressiveness**
* PTBs are fully supported
* Multi-call atomic flows are fully supported

---

## 4. How Enoki fits in (mental model)

**Enoki is not required by the protocol.**
It is an **infrastructure + UX layer** that makes zkLogin *usable at scale*.

Think of Enoki as doing three things:

### 4.1 Identity + session orchestration

Enoki handles:

* OAuth redirect flows
* JWT handling
* zkLogin proof generation (client or delegated)
* Session reuse (so user doesn’t re-login every tx)

Without Enoki:

* You *can* do zkLogin
* But you must implement all of this yourself

With Enoki:

* zkLogin becomes “signTransaction()” in your app

---

### 4.2 Gas & sponsorship abstraction

Enoki makes it easy to:

* Sponsor gas
* Route gas payments
* Bundle “user intent” with “sponsored execution”

This is **critical** for x402:

* Buyer should not need SUI
* Buyer should not think about gas
* Facilitator can control execution guarantees

---

### 4.3 Secure transaction boundary

Enoki helps ensure:

* The user signs **exactly the PTB shown**
* No hidden calls
* No silent object transfers

This matters when:

* PTB is prepared by a third party (facilitator)
* Buyer is not crypto-native

So Enoki acts like:

> “Wallet safety rails, without a wallet.”

---

## 5. Constraints and caveats (important)

### 5.1 Buyer address persistence

* zkLogin addresses are deterministic **only if**

  * Same issuer
  * Same salt
* If salt handling is wrong → address fragmentation

This is solvable, but must be designed carefully.

---

### 5.2 Object ownership model

Buyer *can* own objects via zkLogin, but:

* UX around object recovery is non-trivial
* Many designs instead:

  * Use shared objects
  * Use escrow / pool ownership
  * Use facilitator-managed coins

For x402, this is usually an advantage, not a problem.

---

### 5.3 Trust boundary

Buyer **must trust** that:

* The PTB they sign matches the intent
* The UI faithfully renders effects

This is *no worse* than any wallet UX — but you must be explicit.

---

## 6. Bottom line (for x402)

* zkLogin **can sign facilitator-prepared PTBs**
* Buyer can complete full x402 flow **with zero wallet**
* Enoki is the practical glue:

  * Identity
  * Sessions
  * Gas
  * Safety
* No fundamental protocol blockers
* Constraints are architectural, not cryptographic

If you want, next we can:

* Sketch the **exact x402 flow with zkLogin + Enoki**
* Compare this to your **escrow-pool privacy design**
* Or analyze where **Sui actually simplifies** this vs EVM / Solana

Question:
Wow. Very very helpful. Let me ask a few important follow ons from this info and how I understood it.
1. Can the buyer (theoretically verify the PTB? Like in metamask or ledger? Is this part of Enoki? Important for the trust boundary? At least theoretical verification. Is it assured that facilitator cannt disply in UI pay 0.1 USDC and in rwality it is 100000 USDC?
2. Object ownership persistence is very important. We want to have the USDC coins persisted between multiple payments and vendors. And also never risk to use it.
3. Say more about the shared state solutions against (2) ... and what it means for the hackarhon? This is back again to the Escrow or not question? Explain why or why not.
4. Yes please draft the full flow. And also explain whst happens between switch url in the browser and merchant. Or even if you close or reinstall browser. 
4a. I guess I do not fully understand how the nonce in zkLogin is or is not persisted
5. What else is important to undetstand here? Especially my mental model

Answer:
1. **Yes, the buyer can (in principle) verify the PTB before signing**, analogous to what MetaMask/Ledger do.
2. **But “UI says 0.1 USDC while the signed transaction transfers 100000 USDC” is only prevented if the verifier (wallet/app) parses the exact bytes that will be signed and renders a trustworthy summary.** That is an application responsibility, not something zkLogin gives “for free.”

Below is a concrete mental model for each of your points.

---

## 1) Buyer verification of facilitator-prepared PTB

### What “verification” can mean (in increasing strength)

**A. Byte-level integrity (hard guarantee):**
Buyer signs a digest of specific transaction bytes; facilitator cannot change those bytes after the buyer signs. This is guaranteed by Sui’s signing model. “Construct then sign then submit” is explicit in Sui docs. ([Sui Docs][1])

**B. Human-meaningful preview (UX guarantee):**
Buyer sees a correct preview of what those bytes *do* (transfer amounts, recipients, Move calls).

This is the hard part. Two key observations:

1. **Sui PTBs are fully expressive** (multiple commands, intermediate results, coin splits/merges). ([Sui Docs][2])
2. Rendering “what will happen” requires parsing + simulating/estimating effects.

### Is this “part of Enoki”?

Enoki gives you wallet-like primitives to sign transaction blocks (and integrates with wallet-standard style flows). ([Enoki][3])
But **Enoki is not a hardware wallet** and does not magically solve semantic transaction verification. The app (or Enoki-powered component) must:

* Parse the PTB commands
* Identify coin operations (split/merge/transfer)
* Show user *exact amounts and recipients*
* Ideally simulate effects via RPC (dev-inspect / dry run patterns)

### Can you make it “assured” that the facilitator cannot lie about amount?

You can get very close to “assured” if you adopt one of these patterns:

**Pattern 1 (recommended): Constrained transaction template**

* You define a fixed PTB template for “pay invoice”:

  * split coin for amount `A`
  * transfer that exact split to merchant
  * optional: call receipt/settlement Move function
* Buyer UI verifies that the PTB matches the template and that `A` equals what’s displayed.
* Anything outside the template is rejected.

**Pattern 2: On-chain intent object**

* Buyer signs a PTB that first creates/updates an “Intent” object (amount, merchant, expiry, nonce).
* A second step consumes the intent.
* UI verification becomes trivial: check the intent fields.

**Pattern 3: Off-chain signed quote + on-chain check**

* Facilitator provides a quote (merchant, amount, expiry) signed by facilitator key.
* PTB includes a Move call that verifies quote signature and enforces amount/recipient on-chain.
* Buyer UI checks quote + that the PTB calls the verifying function.

If you do none of these, then “semantic tricking” is possible (not by changing bytes after signing, but by making bytes do something user didn’t understand).

---

## 2) Object ownership persistence for USDC across many payments

You want:

* A persistent balance across sessions/vendors
* No “fund loss” risk
* No repeated wallet onboarding

With zkLogin, persistence reduces to **address persistence**, which reduces to **salt management**.

Sui’s zkLogin flow explicitly calls out:

* You compute the zkLogin address from OAuth identifiers + salt
* Salt must be maintained/managed by the app (or a service you use) ([Sui Docs][4])

So the most important design point is:

### Where does the salt live?

* If salt is lost/rotated, the derived address changes → funds appear “gone” (really: stuck at old address).
* If salt is compromised, attacker with OAuth access + salt can act (zkLogin is intended as 2FA: OAuth credential + salt). ([Sui Docs][5])

This is why many production stacks use a managed solution (Enoki/Shinami-like) or their own secure backend/HSM strategy for salts.

### Where do the coin objects live?

If the buyer directly owns USDC coin objects at their zkLogin address:

* Great persistence
* But UX must handle:

  * coin selection/merging
  * object versioning
  * recovery when browser storage is cleared (address still fine; ephemeral keys are not the funds)

This is feasible; it just pushes you toward robust account management.

---

## 3) Shared-state solutions vs escrow (and hackathon implications)

You asked about “shared state” as an alternative to direct ownership persistence.

On Sui, “shared state” typically means:

* Shared objects that many parties can interact with (with Move access control)
* Or custody/pool objects controlled by a protocol

### Option A: Buyer-owned coins (no escrow)

**Pros**

* Clean mental model: “my USDC is mine”
* No pooled custody risk
* Easy to reason about vendor-agnostic balance

**Cons**

* Requires reliable salt persistence
* Requires gas sponsorship and good coin-management UX
* Facilitator-prepared PTBs must be safely verified (see §1)

### Option B: Escrow/pool design (shared objects)

**Pros**

* Buyer does not need to manage coin objects at all
* Payments become “debit from internal balance”
* Easier to do privacy obfuscation (your earlier motivation)
* Easier for hackathon demo: one pool, simple UX, fewer edge cases

**Cons**

* Custody / trust / governance becomes central
* Must design withdrawal safety + dispute logic
* If you want “no trust in facilitator,” escrow must be credibly neutral (contract-enforced)

### What it means for the hackathon

For a hackathon, the dominant constraint is **time-to-working-demo**. The escrow/pool path often wins because:

* You avoid complicated “buyer coin object persistence” edge cases
* You avoid building a full “safe PTB preview” system
* You can still demonstrate the core x402 flow end-to-end

But: if your thesis is “buyer sovereign funds across vendors,” then you should at least implement a minimal version of Option A and accept some UX rough edges.

---

## 4) Full flow draft (merchant ↔ browser ↔ facilitator), including close/reinstall

Below is an implementable flow that separates:

* Merchant’s web flow
* Facilitator’s transaction construction
* Buyer’s zkLogin signing
* Persistence across sessions

### Actors

* **Merchant site**
* **Facilitator service**
* **Buyer browser**
* **Sui network**

### Step-by-step

1. **Merchant returns 402 challenge**

   * Buyer requests resource.
   * Merchant replies “Payment Required” with payment parameters:

     * amount, asset (USDC), merchant address/object, expiry, payment_id, facilitator endpoint.

2. **Browser redirects/opens facilitator payment page**

   * The buyer lands on facilitator UI with:

     * merchant domain
     * amount
     * payment_id
     * callback URL to merchant

3. **zkLogin session acquisition**

   * If no active zkLogin session:

     * generate ephemeral keypair
     * start OAuth login with **nonce bound to ephemeral public key** (zkLogin design binds ephemeral key in nonce) ([Sui Docs][4])
   * Get JWT in redirect URL.
   * Obtain zk proof (via your prover / Enoki / service).
   * Derive buyer zkLogin address using salt + JWT identifiers. ([Sui Docs][4])

4. **Facilitator constructs PTB**

   * Inputs:

     * buyer address
     * merchant destination
     * amount
     * buyer coin objects (or pool balance)
   * PTB does:

     * split coin for exact amount
     * transfer to merchant
     * optional: Move call to emit receipt event with payment_id
   * Facilitator sends PTB bytes (or transaction kind) to browser.

5. **Buyer verification + signing**

   * UI parses PTB and displays:

     * “Pay 0.1 USDC to Merchant X”
   * Buyer signs transaction digest using ephemeral private key + zkLogin proof bundle. ([arXiv][6])

6. **Submission**

   * Either:

     * Buyer submits to RPC directly, or
     * Facilitator submits (still cannot change bytes after signature)
   * Gas is sponsored (common with Enoki-like stacks).

7. **Return to merchant**

   * Facilitator returns browser to merchant callback URL with:

     * tx digest
     * payment_id
   * Merchant verifies on-chain:

     * tx succeeded
     * correct amount/recipient
     * correct payment_id (via events/receipt object)

### Close browser / reinstall implications

There are three distinct “persistence” layers:

1. **Funds persistence:** on-chain at the zkLogin-derived address (depends on salt stability). ([Sui Docs][4])
2. **Session persistence:** OAuth session / refresh token and/or cached zk proof (app-specific)
3. **Ephemeral key persistence:** keys used for signing during a short window; proofs/keys have an expiry notion tied to epochs/maxEpoch. External docs describe maxEpoch as governing expiration, and that you must re-login when it expires. ([Shinami Docs][7])

If the browser storage is wiped:

* You can still recover the same on-chain funds **if** you can re-derive the same address (same OAuth identity + same salt).
* You will generate a new ephemeral key and do a new zkLogin proof cycle (normal).

---

## 4a) Nonce in zkLogin: what persists and what doesn’t

In zkLogin, the OAuth JWT contains a **nonce** that is constructed to “commit” to the ephemeral public key (so the JWT effectively certifies that ephemeral key). ([Sui Docs][4])

Practical interpretation:

* **Nonce is not your “account nonce”** like Ethereum.
* It is part of the **login binding** that prevents replay/impersonation with a different ephemeral key.
* You generally do **not** persist the nonce across long time.
* What you persist (for account continuity) is **salt** (and issuer/audience consistency).

---

## 5) What else is important for your mental model

### A. Separate “address identity” from “signing session”

* Address identity: stable via (issuer, subject, audience, salt). ([Sui Docs][4])
* Signing session: ephemeral key + proof, time-bounded (epochs/maxEpoch). ([Shinami Docs][7])

### B. If you want “no wallet,” you must replace wallet functions

A wallet normally provides:

* transaction preview
* phishing resistance
* account persistence UX
* gas handling
* coin selection

If you remove the wallet, you must implement enough of these (or adopt Enoki-like tooling) to keep the trust boundary acceptable.

### C. For x402, decide what you are optimizing first

You cannot simultaneously maximize all of:

* Minimal trust in facilitator
* Strong user verification guarantees
* Max privacy against indexers
* Fast hackathon demo
* No wallet / no gas / no friction

Pick 2–3 as “must have” for MVP, and architect the rest as an upgrade path.

If you want the most robust “no facilitator lying about amount” MVP, the fastest route is: **transaction template + strict local verification** (Pattern 1 in §1).

[1]: https://docs.sui.io/guides/developer/sui-101/sign-and-send-txn?utm_source=chatgpt.com "Signing and Sending Transactions"
[2]: https://docs.sui.io/concepts/transactions/prog-txn-blocks?utm_source=chatgpt.com "Programmable Transaction Blocks"
[3]: https://docs.enoki.mystenlabs.com/ts-sdk/transactions?utm_source=chatgpt.com "Signing Transactions"
[4]: https://docs.sui.io/guides/developer/cryptography/zklogin-integration?utm_source=chatgpt.com "zkLogin Integration Guide"
[5]: https://docs.sui.io/concepts/cryptography/zklogin?utm_source=chatgpt.com "zkLogin | Sui Documentation"
[6]: https://arxiv.org/pdf/2401.11735?utm_source=chatgpt.com "zkLogin: Privacy-Preserving Blockchain Authentication with ..."
[7]: https://docs.shinami.com/api-docs/sui/wallet-services/zklogin-wallet-api?utm_source=chatgpt.com "zkLogin wallet API - Shinami Developer Documentation"

Question:
When you say "application level resposnibility": there is no app the buyer controls per se. This would be an additional component for the buyer. Or is this provided by Enoki? Also for the pattern under your answer (1). You say buyer verifies ... creates ... rejects. But with which infrastructure/component? I agree that pattern 1 feels best because the others seem complicated. But does this conflict with facilitator proposed merge split?

To 2:
On the object persistence, seems like trusting Enoki with it seems best ... if this solves our design challenges. Quickly explain the trust assumptions Enoki requires from us.
Can the facilitator explore availabe coins owned by the buyer and then in the PTB prepare and out in the relvant ones? Then this is not a UI decision to select / merge but can be prepared by facilitator? Why or why not?
P.S.: extension idea: the PTB could even exchange coins through Deepbook if the buyer lacks the merchant requested coin? Would be an aditional facilitator service. Keep as extensiin idea. But not for hackathon implentatuon.
On 3:
Good explanation. Still undecided. My sympathy is for non escrow
On 4
This makes it very transparent for me. 
We are missing: how the initial coin<usdc> lands / is acquitered when the zkLogin buyer address is created first (our faucet or crwdit card interpersal if funds are lacking)
On 4 and 4.7: we should definitely emit the event and have it for rhe merchant audit. Include it
On 4.6. We should implement through facilitator (would be different for agentic). We want to keep the buyer RPC free.
On 5A: You are right. I confused nonce with salt. I need salt persistence. My understanding now: salt persistence is challenge session level is tablestakes. Right?
On 5B: good you point it out. I want to rely on Enoki and not implement myself. 
On 5C: Thanks for forcing me into chosing the trade offs. Let me try:
- Higest prio: no UX friction, no gas, no wallet
- High prio: still web3 not web2 when it comes to trust in facilitator. Makes sense? We do not want to create a delegated web2 service. 
- We sacrifice for hackathon indexer privacy. We have broken the OAuth link to address at least with zkLogin
- we shoulf have fast hackathon demo. But my feel is that we can solve this by pre-allocating coin USDC before or have a "private faucet script" ... or am I missing somerhing?
- intuition: not escroe based
Good choices? From feasibility and from demo impact? 

Answer:
## 1) “Application-level responsibility” when the buyer has no app

You still need *some* buyer-side component that produces the zkLogin signature. It can be:

* **Your web UI** (merchant-hosted or facilitator-hosted web page), using Enoki SDK, or
* A **wallet / extension** (which you explicitly don’t want), or
* A native app (also not desired).

So in your model, “the application” = **the payment page’s JS running in the buyer’s browser**.

Enoki helps by providing primitives to obtain zkLogin credentials and sign transaction blocks, but it is not a magic “truth oracle” for what the PTB does. Enoki is still used *inside* that web UI. ([docs.enoki.mystenlabs.com][1])

### What prevents “UI says 0.1 USDC but actually signs 100000 USDC”?

Only one thing is fundamental:

* The user signs a digest of the exact transaction bytes; those bytes can’t be altered after signing. ([Sui Documentation][2])

But the UI could still lie about what those bytes mean. To prevent that, you need a **local verifier/renderer** that:

1. Parses the transaction block bytes you are about to sign, and
2. Displays the payment summary derived from those bytes, not from facilitator-provided metadata.

That verifier can live in the same JS UI. It does not require a separate installed component.

---

## 1a) Pattern 1 (“template verification”) and whether it conflicts with facilitator merge/split

It does **not** conflict if you define the template to *allow* standard coin hygiene.

Typical allowed set for a pay template:

* Optional: merge some USDC coins into one coin
* Required: split out exact amount `A`
* Required: transfer that split to merchant
* Optional: emit receipt event / call receipt Move function

The “template verifier” checks:

* Only allowed commands are present
* Amount `A` and merchant recipient match the invoice/challenge
* Any merges/splits are only involving **USDC coin objects** owned by the payer address (or explicitly listed inputs)

This is compatible with facilitator-prepared coin selection/merge/split. It just constrains it.

Reference point: PTBs are explicitly meant to include sequences of commands like merges/splits/transfers. ([Sui Documentation][3])

---

## 2) Trust assumptions if you “trust Enoki with persistence”

The core persistence problem is the **salt**. Salt is essential both for zkLogin address derivation and for proofs; leaking it weakens privacy and can be security-relevant. ([Sui Documentation][3])

If you use Enoki’s default salt / hosted services, the trust assumptions become:

1. **Availability**: Enoki’s services are reachable when users log in / re-auth (salt/proof infrastructure as used by Enoki flows). ([Sui Documentation][2])
2. **Correctness**: Enoki returns the correct per-user salt derivation and zk proof generation results. ([docs.enoki.mystenlabs.com][1])
3. **Privacy boundary**: Enoki (or any salt server) is part of the privacy story separating Web2 identity from on-chain address. The Mysten salt-server architecture explicitly treats the master seed as sensitive and emphasizes hardening. ([The Sui Blog][4])
4. **Not custody of funds**: Enoki does not “hold” user funds; funds sit on-chain at the derived address. Enoki influences whether you can reliably re-derive that address and produce signatures. ([docs.enoki.mystenlabs.com][1])

Net: you’re trusting Enoki similarly to how you’d trust a hosted auth + key-management helper: not with funds custody, but with **identity→address continuity** and **proof plumbing**.

---

## 2a) Can the facilitator select/merge coins for the buyer (so UI doesn’t do it)?

**Yes, technically**: the facilitator can query the chain for the buyer’s owned USDC coin objects, pick inputs, and build a PTB that merges/splits appropriately.

However, two constraints:

1. **The buyer must sign a transaction that references specific input objects.** If the facilitator chooses different coins than what the UI shows, the UI must still verify based on the final bytes.
2. **Sponsored tx policy / allowlists**: If you use sponsored transactions via Enoki-style setup, you may restrict which Move targets/addresses are eligible for sponsorship (this is a common pattern; Enoki example materials mention configuring supported targets). ([GitHub][5])

So: facilitator-driven coin selection is fine, and often preferable for UX. It just increases the importance of template verification on the buyer signing page.

### Extension idea: swapping via Deepbook in the PTB

Conceptually feasible (PTB can include additional calls), but it increases:

* slippage/quote handling
* MEV/price risk
* user-intent verification complexity

Good as a later extension, not hackathon.

---

## 3) “Shared state” vs non-escrow, revisited for your priorities

Given your stated priorities:

* no wallet, no gas, minimal friction
* avoid “delegated Web2 service” trust
* fast demo
* privacy lower priority for hackathon
* non-escrow intuition

A workable compromise that stays non-escrow:

* **Buyer owns USDC coins at zkLogin address** (self-custody on-chain)
* **Facilitator sponsors gas + constructs PTBs**
* **Buyer signs in-browser via Enoki**
* **Template verification in the signing page** (so facilitator can’t silently overcharge)
* **Merchant audits via receipt event**

Escrow/pool simplifies some edges, but it increases the “service trust” perception. With non-escrow you keep the story: “funds always in buyer address; facilitator can’t move them without signature.”

---

## 4) Full flow (updated) including initial USDC acquisition, receipt event, and buyer RPC-free

### 4.0 One-time: buyer address creation

* User logs in via zkLogin (Enoki).
* Address is derived deterministically (salt-backed). ([docs.enoki.mystenlabs.com][1])

### 4.1 Funding paths (getting the first Coin<USDC> there)

You have three hackathon-friendly options:

**Option A — Faucet/airdrop USDC on testnet/devnet**

* After address creation, your backend sends a Coin<USDC> object to buyer address.

**Option B — “Private faucet script” (your phrasing)**

* Same as A, just gated (invite code / allowlist).

**Option C — Onramp later**

* Defer: for demo, pre-fund addresses.

For hackathon, A/B is simplest and does not change the payment flow.

### 4.2 Merchant 402 challenge

Merchant returns:

* amount, asset (USDC), merchant recipient, payment_id, expiry, facilitator URL

### 4.3 Buyer goes to facilitator payment page (browser)

* Page shows invoice terms (from merchant)
* Page obtains zkLogin session if needed (or reuses cached proof/key until expiry). ([Sui Documentation][2])

### 4.4 Facilitator constructs PTB (server-side)

* Fetch buyer USDC coins from chain
* Select inputs, merge as needed
* Split exact amount
* Transfer to merchant
* Call `receipt::emit(payment_id, merchant, amount, asset, buyer)` (or emit event in same module)

### 4.5 Buyer-side template verification + signing (in browser)

* The web page parses the returned PTB bytes and verifies:

  * template conformance
  * amount/recipient/payment_id match the invoice
* Then signs via zkLogin (EnokiKeypair-style flow). ([Mysten Labs TypeScript SDK Docs][6])

### 4.6 Submission (facilitator submits)

* Buyer sends signature bundle back to facilitator
* Facilitator submits to Sui RPC
* Buyer never touches RPC directly

### 4.7 Return to merchant + merchant audit

* Facilitator redirects browser to merchant callback with tx digest + payment_id
* Merchant verifies on-chain:

  * tx success
  * receipt event exists and matches payment_id/amount/asset/buyer

---

## 4a) Nonce vs salt persistence

Your updated understanding is correct:

* **Salt persistence is the real “account continuity” problem.**
* **Session persistence (ephemeral key + proof) is operational/tactical**, and you can cache it until expiry (`maxEpoch` pattern is explicitly described in zkLogin integration guidance). ([Sui Documentation][2])

So: yes—salt persistence is the hard part; session caching is table-stakes.

---

## 5) Your tradeoff choices: feasibility + demo impact

These are coherent and feasible:

* **No UX friction / no gas / no wallet**: achievable with Enoki + sponsorship. ([enoki.mystenlabs.com][7])
* **Keep Web3 trust boundary**: achievable if (a) buyer signs every spend and (b) you enforce template verification.
* **Indexer privacy sacrificed for hackathon**: fine. zkLogin already improves the “OAuth identity not trivially visible on-chain” angle, but full privacy is a later phase.
* **Fast demo via prefunding**: yes; prefunding addresses removes the onramp complexity.
* **Non-escrow**: consistent with your trust boundary goal; escrow is a valid later optimization if you need pooling/privacy.

The one thing you must not skip (even for hackathon) if you want “not delegated Web2”:

* **Buyer-side template verification before signing.**
  Otherwise the facilitator becomes effectively a wallet with hidden power.

If you want, next step: I can write the exact “template” as a formal checklist (allowed PTB commands + required invariants) suitable for implementation in a small verifier module in the payment page JS.

[1]: https://docs.enoki.mystenlabs.com/ts-sdk?utm_source=chatgpt.com "Enoki TypeScript SDK"
[2]: https://docs.sui.io/guides/developer/cryptography/zklogin-integration?utm_source=chatgpt.com "zkLogin Integration Guide"
[3]: https://docs.sui.io/concepts/cryptography/zklogin?utm_source=chatgpt.com "zkLogin | Sui Documentation"
[4]: https://blog.sui.io/zklogin-salt-server-architecture/?utm_source=chatgpt.com "Dive into zkLogin's Salt Server Architecture"
[5]: https://github.com/sui-foundation/enoki-example-app?utm_source=chatgpt.com "sui-foundation/enoki-example-app"
[6]: https://sdk.mystenlabs.com/typedoc/classes/_mysten_enoki.EnokiKeypair.html?utm_source=chatgpt.com "EnokiKeypair | Documentation"
[7]: https://enoki.mystenlabs.com/?utm_source=chatgpt.com "Enoki - Mysten Labs"

Question:
Agree and undrrstood. Let us further specify:
On 4.1 funding path: option A: and even show this im UI demo for first payment. We show then a consecutive payment. Makes sense
On 4.7: for demo, we show the receipt onchain... mention for audit and conflict resolution. Or should this be without emit and pure ephemersl note consumption? Gas cost of emit relevant? We can decide snd change this later in the hack. But capture the trade off.
4a. Capture in spec that we need the nonce mangement. Ot not needed for demo. Will definitely do through enoki if needed.
OK Buyer side template verification is key. Double doen on it. How are we in full detail do this. How do we show this in the demo? Can we simplify this through some onchain contract that binds facilitator, e.g. through zk (a bit wild idea?)
Yes. Write the full spec: we will use as a spec for cursor? 
Anything else?

Answer:
## x402 on Sui with zkLogin + Enoki — Hackathon Spec (v0)

### Scope and goals

* Buyer completes payments **without wallet extension**, **without gas**, using **zkLogin via Enoki**.
* Funds remain **self-custodied** at buyer zkLogin address (non-escrow).
* Facilitator prepares PTBs and submits transactions; buyer only signs.
* Buyer-side **template verification** is mandatory and demonstrated.

---

## 1) Actors and components

### Actors

* **Buyer**: browser user, authenticates via OAuth, signs via zkLogin.
* **Merchant**: web server providing paid resource.
* **Facilitator**: service that sponsors gas, constructs PTBs, submits tx.
* **Sui chain**: settlement + receipt event.

### Components

* **Merchant site**:

  * 402 response endpoint (challenge)
  * callback/verify endpoint
  * demo UI page to show “paid / receipt”
* **Facilitator service**:

  * build payment PTB
  * sponsor gas
  * submit signed tx
  * optional: funding faucet endpoint
* **Buyer payment page (web)**:

  * runs zkLogin session (via Enoki)
  * runs template verifier on PTB bytes
  * signs PTB digest and returns signature bundle to facilitator

---

## 2) Funding path (demo: “first payment” + “consecutive payment”)

### 2.1 Demo flow intent

* First time user pays: they have **0 USDC**, UI shows “fund your account (demo faucet)”.
* After funding: user pays merchant (Payment #1).
* Then immediately pay again (Payment #2) to demonstrate **coin persistence** and **no extra setup**.

### 2.2 Funding mechanism (Option A)

* After zkLogin address exists, buyer presses “Fund (demo faucet)”.
* Facilitator faucet endpoint transfers testnet/devnet **Coin<USDC>** to buyer address.

**Faucet requirements**

* Amount: enough for at least 2 payments.
* Idempotency: keyed by `(buyerAddress, faucetSessionId)` to avoid repeats.
* UI shows:

  * buyer address
  * faucet tx digest
  * resulting USDC balance

---

## 3) Payment protocol

### 3.1 Merchant 402 challenge

When buyer requests protected resource:

* Merchant returns **402 Payment Required** with metadata:

  * `amount` (e.g., 0.1)
  * `assetType` (USDC type tag)
  * `merchantRecipient` (address)
  * `payment_id` (unique)
  * `expiry` (timestamp)
  * `facilitator_url`
  * `merchant_callback_url`
  * optional `memo` / item description

### 3.2 Buyer redirected to facilitator payment page

* Browser opens `facilitator_url?payment_id=...&callback=...`
* Facilitator page fetches challenge details from merchant (server-to-server or via signed payload).

### 3.3 zkLogin session (via Enoki)

* If no active session, buyer clicks “Sign in”.
* Enoki performs OAuth + zkLogin proof steps.
* Page displays:

  * buyer zkLogin address
  * session state (active / needs refresh)

**Hackathon simplification**

* Assume Enoki handles nonce/JWT/proof plumbing.
* If session expires, user re-authenticates; address remains same via salt.

### 3.4 Facilitator constructs PTB (server-side)

Inputs:

* challenge details
* buyer address
* selected buyer USDC coin objects (queried from chain)
* gas sponsor

PTB semantics:

1. (Optional) merge some USDC coins to reach sufficient balance
2. split exact amount `A` from a chosen coin
3. transfer split to `merchantRecipient`
4. **emit receipt** (see Section 4)

Facilitator returns to buyer page:

* serialized transaction block bytes (the exact bytes to sign)
* a human-readable “expected summary” (not trusted; used only as UI convenience)
* optional: list of input object ids used

### 3.5 Buyer-side template verification (mandatory)

Buyer page parses the returned transaction bytes and verifies invariants (Section 5).

If verification passes:

* Buyer signs the transaction digest via Enoki zkLogin key/session.
* Buyer sends signature bundle back to facilitator.

If verification fails:

* UI shows “transaction does not match invoice” + reason, abort.

### 3.6 Facilitator submits transaction

* Facilitator submits signed tx to Sui RPC.
* Facilitator returns:

  * tx digest
  * execution status
  * receipt reference (event fields or emitted object id)

### 3.7 Return to merchant + merchant verification

Browser redirects to `merchant_callback_url` with:

* `payment_id`
* `tx_digest`

Merchant verifies on-chain:

* tx succeeded
* transfer to merchant recipient for `amount` in USDC occurred
* receipt present and consistent (if used)

---

## 4) Receipt design and tradeoffs (emit vs “ephemeral note consumption”)

### Option R1 — Emit on-chain receipt event (recommended for demo)

Receipt event fields:

* `payment_id`
* `buyerAddress`
* `merchantRecipient`
* `amount`
* `assetType`
* `timestamp` (or block time equivalent)
* optional: `invoiceHash` / metadata hash

**Pros**

* Easy merchant audit and demo visualization
* Supports conflict resolution and reconciliation
* Simple verification: “find event by payment_id”

**Cons**

* Additional gas for emitting event
* Makes payment metadata more indexable (privacy tradeoff)

### Option R2 — No receipt event; merchant infers from transfer

**Pros**

* Lower gas
* Less metadata leakage

**Cons**

* Harder merchant-side reconciliation (must scan transfers)
* Harder to prove intent/payment_id binding
* Demo is less clear

### Option R3 — “Ephemeral note consumption” / object-based receipt

(Receipt object created and immediately consumed, or created then stored)
**Pros**

* Can encode richer logic (nonces, one-time claims)
* Can separate “proof” from “event”

**Cons**

* More Move work + time
* For hackathon, higher complexity with limited upside

**Hackathon decision**

* Use **R1** (event). Keep a config flag to disable later.

---

## 5) Buyer-side template verification (full detail)

### 5.1 Purpose

Prevent a malicious/buggy facilitator UI from tricking the buyer into signing a transaction that differs from the invoice.

### 5.2 Verification must be derived from **bytes to be signed**

Do not trust facilitator-provided “summary”.
The verifier inspects the transaction block content and enforces a strict template.

### 5.3 Allowed command set (strict)

Allowed only:

* `MergeCoins` (USDC-only)
* `SplitCoins` (USDC-only)
* `TransferObjects` (only the split coin for payment; optionally change coins back to buyer)
* `MoveCall` to a **single approved module/function** for receipt emit (optional)
* No other commands

### 5.4 Required invariants

Given invoice `(amount A, merchantRecipient M, assetType USDC, payment_id P, expiry E)`:

1. **Asset type** is exactly USDC for all coin operations.
2. Exactly one transfer of **amount A** USDC to **M** occurs.

   * Mechanically: verify the split produces a coin of value A and that coin is transferred to M.
3. No transfer of any other assets/objects to non-buyer addresses.
4. Any change coins remain owned by buyer address.
5. If receipt is enabled:

   * There is exactly one `MoveCall` to `receipt::emit` (or equivalent)
   * Arguments match `P, buyer, M, A, USDC`
6. `expiry` is respected:

   * Either enforced by app before signing (current time < E),
   * Or enforced in receipt MoveCall (optional in hackathon).

### 5.5 Facilitator merge/split compatibility

Facilitator may choose inputs and perform merges/splits as long as:

* all are USDC coins owned by buyer
* the final transfer is exactly amount A to M
* no extra outward transfers

### 5.6 Demonstrating verification in demo

UI shows:

* “Invoice: pay A USDC to M”
* “Parsed transaction: pay A USDC to M” (derived from bytes)
* “Template check: PASS”
* Button: “Sign and Pay”

Optional “attack demo” (nice-to-have):

* Facilitator deliberately returns a PTB with amount `A * 10`
* Verifier shows “FAIL: amount mismatch” and blocks signing

---

## 6) “Simplify verification via on-chain binding to facilitator” (your idea)

You can add an on-chain guardrail, but it does not replace buyer-side verification; it complements it.

### Practical on-chain guard (low complexity)

* Put the payment execution behind a Move function `pay_exact(...)` that:

  * takes `amount`, `merchant`, `payment_id`
  * enforces `amount == invoice.amount` (invoice data provided as argument or stored)
  * performs the split/transfer internally
  * emits receipt event

Then the verifier checks only:

* the PTB calls `pay_exact` with correct args
* no other disallowed commands

This reduces parsing complexity and reduces room for semantic trickery.

### Why not “zk-binding facilitator” for hackathon

* Adds prover complexity and doesn’t address the core: user must still be shown what they sign.
* For hackathon: skip. Keep as future enhancement.

---

## 7) Session, nonce, salt — what the spec requires

### 7.1 Salt persistence (must-have)

* Address continuity depends on stable salt.
* Enoki is used to manage this (do not DIY for hackathon).

Spec requirement:

* Buyer address must remain stable across:

  * closing tab
  * reopening browser
  * consecutive payments

### 7.2 Nonce/JWT/proof lifecycle (handled by Enoki)

Spec requirement:

* If zkLogin session expires, user may re-auth.
* This should not affect address or funds.
* For hackathon, we do not implement custom nonce management; we rely on Enoki.

---

## 8) Demo script (what judges see)

1. Open merchant page → attempt to access protected content → 402 “payment required”
2. Redirect to facilitator payment page
3. “Sign in with OAuth” → show derived buyer address
4. “Fund (demo faucet)” → show faucet tx digest and USDC balance
5. Click “Pay 0.1 USDC”

   * show parsed-from-bytes transaction summary
   * show template verification PASS
   * sign (zkLogin)
6. Facilitator submits tx → show tx digest
7. Return to merchant → content unlocked
8. Merchant “Audit” panel:

   * tx digest
   * receipt event fields (payment_id, amount, buyer, merchant)
9. Repeat payment (Payment #2) without funding again to demonstrate persistence

Optional:

* Show “malicious PTB blocked” screen.

---

## 9) Open decisions (explicitly tracked)

* Receipt mode: **R1 event** for demo; keep a switch for later.
* Whether to enforce `expiry` on-chain vs client-only for hackathon (client-only is acceptable for demo).
* Whether to centralize payment execution in a `pay_exact` Move function (recommended if time allows; simplifies verification).

---

## 10) Anything else important

* **Idempotency / replay**: Merchant should treat `(payment_id)` as single-use; on-chain receipt makes this easy.
* **Failure handling**:

  * If tx fails (insufficient USDC), UI offers “Fund again” (demo) and rebuilds PTB.
* **Minimal trust story** (demo narrative):

  * Facilitator cannot spend without buyer signature.
  * Buyer signs only transactions that pass template verification derived from signed bytes.
  * Merchant can independently audit receipt on-chain.

If you want this to be directly usable as a Cursor task spec, the next step is to convert Sections 2–8 into a checklist of endpoints and data structures (request/response JSON) for merchant and facilitator plus the exact verifier rule set as a formal schema.

Question:
Outstanding.   Please add: We are missing the merchant embedded JWT. Needs to be embedded in merchant side. Clear what I mean?  Invoice hash not optional. Let us include. This improves over Eip3009 and makes audit/conflict resolution sensible Agree on R1 with flag  Again. Which code and program does the buyer side verification? How does it get into the buyer browser? In reality (could later be a browser plugin)? For demo? Why i am not getting this? My mentsl model? 

Answer:
## Additions to the spec

### A) Merchant-embedded JWT (what it is and where it lives)

Yes—clear. You want the merchant to issue a **merchant-signed, tamper-evident invoice token** that travels through the flow and is bound into the on-chain receipt.

**Definition (Invoice JWT):**

* A JWT (or JWT-like signed token) created by the merchant that encodes the invoice terms.
* Signed by the merchant (e.g., ES256 / EdDSA / whatever you choose).
* Carried by the buyer to the facilitator and then committed on-chain via `invoice_hash`.

**Invoice JWT claims (minimum):**

* `iss`: merchant identifier (domain or public key id)
* `aud`: facilitator identifier (optional but recommended)
* `iat`, `exp`: issuance + expiry
* `payment_id`: unique per invoice
* `amount`, `assetType`
* `merchantRecipient`
* `resource`: what is being purchased (URL/path/product id)
* `nonce` (merchant-side uniqueness, if desired)

**Where it’s embedded:**

* Merchant returns it in the 402 response, e.g.:

  * `X-X402-Invoice-JWT: <token>` header, or
  * JSON body field `invoice_jwt`
* Buyer forwards it to facilitator unchanged.

**Purpose:**

* Facilitator cannot alter invoice terms without invalidating the merchant signature.
* Merchant can later prove exactly what it asked the buyer to pay.

This becomes the canonical “invoice artifact” for audit/conflict resolution.

---

### B) Invoice hash is mandatory (committed on-chain)

Agreed. Make `invoice_hash` mandatory and derived from the merchant invoice JWT.

**Rule:**

* `invoice_hash = H(invoice_jwt_bytes)` (use a standard hash, e.g., SHA-256, BLAKE2, etc.)
* The receipt event includes `invoice_hash` always.
* Merchant stores `(payment_id, invoice_jwt, invoice_hash, tx_digest)`.

**Receipt event fields (updated, mandatory):**

* `payment_id`
* `invoice_hash`  ✅ mandatory
* `buyerAddress`
* `merchantRecipient`
* `amount`
* `assetType`
* `timestamp` (or epoch / tx digest reference)

**Why this helps (practically):**

* If there’s a dispute, the merchant produces `invoice_jwt`; anyone hashes it and compares to on-chain `invoice_hash`.
* This is a clean audit trail and prevents “he said/she said” around invoice parameters.

---

## The core confusion: “Which code verifies the PTB, and how does it get into the buyer’s browser?”

### The key mental model

There is always *some code* running in the buyer’s browser that:

1. Displays the UI
2. Initiates zkLogin signing
3. (In your design) verifies the PTB bytes before signing

When I said “application-level responsibility,” I did **not** mean the buyer installs their own application. I meant:

> The buyer is using a web page. That web page is the “application.”

### For the demo, the verifier is:

* A **JavaScript module** inside the **facilitator-hosted payment page** (or merchant-hosted page; facilitator-hosted is simplest).
* It is delivered to the buyer the same way any web app is delivered: HTTP → browser loads HTML/JS.

So the verifier is not a separate component. It’s just part of the payment page code.

### Why this is acceptable and how it differs from a wallet/extension

* In MetaMask, the verification/preview code runs in an extension.
* In your demo, it runs in a web page.
* Security-wise, an extension can be harder to tamper with than an arbitrary webpage, but for hackathon/demo and early product iterations, a webpage is realistic.

### “But if the facilitator hosts the page, can’t they just remove the verifier?”

Yes—if the facilitator is malicious, they can serve a page that lies.

That’s why there are two different threat models:

1. **You control the facilitator code** (your project).

   * Then the verifier is your internal safety mechanism and a demo feature.
2. **You want a buyer safety boundary against a potentially malicious facilitator.**

   * Then you eventually need a buyer-controlled verifier (extension/wallet/native app) *or* strong third-party guarantees (below).

For hackathon, you are in model (1). The verifier is still valuable because it:

* Proves the architecture
* Makes the trust boundary explicit
* Is the foundation for later hardening (extension)

---

## How to harden later (without changing the protocol)

You have three realistic upgrade paths:

### Path 1 — Browser extension / wallet-like verifier

* Same verifier logic, but shipped as an extension.
* Extension intercepts “sign request,” parses PTB bytes, renders summary, enforces template.
* Strongest buyer-controlled guarantee.

### Path 2 — Merchant-hosted verification page

* Instead of facilitator hosting the signing UI, the merchant hosts the signing UI.
* Merchant fetches PTB from facilitator, verifies it, then asks buyer to sign.
* Shifts trust away from facilitator toward merchant (sometimes acceptable, sometimes not).

### Path 3 — On-chain “pay_exact” contract to constrain meaning

As noted in the spec: move semantics into a single Move call, so verification reduces to:

* “Is this a call to `pay_exact` with these args?”
* “Are there any disallowed extra commands?”

This reduces the surface area for semantic trickery *even in a webpage UI*.

It still does not prevent a malicious page from lying about the args, but it makes both:

* automated checking simpler
* later extension implementation trivial

---

## Spec updates (concise deltas)

### Merchant 402 response now includes:

* `invoice_jwt` (merchant-signed)
* `payment_id`, `expiry` (also inside JWT)
* `facilitator_url`, `callback_url`

### Facilitator must:

* Accept `invoice_jwt`
* Compute `invoice_hash = H(invoice_jwt)`
* Build PTB that:

  * pays exactly the invoice amount/asset to merchant recipient
  * emits receipt with `payment_id` and `invoice_hash` (mandatory)

### Buyer-side verifier must check:

* PTB matches invoice parameters extracted from `invoice_jwt` (not from facilitator text)
* Amount/recipient/asset match exactly
* Receipt call includes `payment_id` and `invoice_hash`

---

## Answering your “why am I not getting this?” directly

You are implicitly assuming “buyer has no app” means “buyer has no code running on their side that we can trust.”

But a browser always runs code from *somewhere*. You have to choose who supplies it:

* facilitator supplies it (demo)
* merchant supplies it
* buyer installs it (extension)

For the hackathon, “buyer has no wallet” simply means:

* no extension
* no seed phrase
* no manual gas

It does **not** mean “no buyer-side execution.” The buyer-side execution is the web payment page.

If you want, I can rewrite the verification section as two tiers in the spec:

* **Tier 1 (hackathon):** verifier in facilitator web app
* **Tier 2 (production hardening):** verifier in extension/wallet or merchant-hosted signing UI

Question:
Now. Very clear. Please add the 2 tiers.
We can exclude merchant verification. In practice a malicious facilitator is less likely than a malicious merchant. Correct?

Answer:
## Spec update: two-tier verification model

### Tier 1 — Hackathon / MVP (webpage verifier)

**Where verifier runs:** facilitator-hosted payment page (browser JS).
**Who supplies code:** facilitator (your project).
**What it guarantees:**

* Buyer signs only PTBs that pass a strict template check **as implemented by your page**.
* Prevents accidental/buggy facilitator PTBs from overcharging.
* Demonstrates the architecture and the intended safety boundary.

**What it does not guarantee:**

* It does not protect against a *malicious facilitator* serving a modified page that lies or skips checks.

**Demo requirement:**

* UI must show:

  * invoice JWT decoded summary
  * parsed-from-bytes PTB summary
  * template verification PASS/FAIL
  * optional “attack PTB blocked” toggle

---

### Tier 2 — Production hardening (buyer-controlled verifier)

**Where verifier runs:** buyer-controlled component, e.g.:

* browser extension (“x402 verifier”)
* wallet integration (if ever acceptable)
* native wrapper app (less likely)

**Who supplies code:** buyer installs/chooses it (trust anchor shifts to buyer).
**What it guarantees:**

* A malicious facilitator cannot trick the buyer into signing an off-template PTB, because verification is executed in a component the facilitator cannot alter at runtime.

**Recommended additional hardening in Tier 2:**

* Constrain payment semantics further with a single Move entrypoint (`pay_exact`) so extension verification becomes trivial: “only allowed call + args match invoice + no extra commands.”

---

## Excluding merchant-hosted verification

Agreed. Merchant-hosted verification (merchant supplies the signing UI) is optional and not needed in this design.

---

## “Malicious facilitator less likely than malicious merchant?”

Not reliably. The more accurate statement is:

* **In your architecture, the merchant is untrusted with respect to payment execution** (the merchant wants to get paid; they may attempt overcharging if they can).
* **The facilitator is also untrusted in principle** (they construct transactions and handle submission), but in *your product* you often control it or contractually govern it.

Which is “more likely” depends on deployment model:

### If facilitator is “your service”

* Malicious facilitator is less likely (you control it).
* Merchant could be any third party; malicious merchants become more likely as you scale.
* Tier 1 is acceptable for hackathon; Tier 2 is for users who want buyer-controlled guarantees.

### If facilitator is an open market / third-party

* Malicious facilitator risk increases.
* Tier 2 becomes essential for a strong trust story.

So: for hackathon and your near-term MVP where you operate the facilitator, it is reasonable to prioritize defense against **merchant manipulation of the invoice** (merchant JWT + invoice hash) and against **facilitator bugs** (Tier 1 verifier), then harden against malicious facilitators with Tier 2 when you decentralize or open the facilitator role.


Question:
Agreed. I think this is right. I think for facilitator credibility it will be important to have him offer the validator extension whichvcan be also audited in the extension marketplaces. ... but this step is "obvious" to judges though tedious in practice. Right?

Answer:
Yes. Your intuition is correct, and judges will generally see this as **the obvious and correct maturation path**, not as a missing conceptual piece.

A precise way to frame it:

* **For the hackathon:**

  * The security boundary is *architecturally sound*.
  * You explicitly show where trust lives today (facilitator-hosted verifier).
  * You explicitly show how that trust is removed (buyer-controlled verifier).

* **For production credibility:**

  * The facilitator offering a **verifier browser extension** is the natural next step.
  * Extension marketplaces (Chrome / Firefox / Safari) provide:

    * public source code links
    * reproducible builds
    * update transparency
    * independent auditing signals

Judges are not expecting you to ship the extension; they are checking:

1. **Do you understand the trust boundary?**
2. **Do you know exactly how to move it?**
3. **Is the protocol already compatible with that move without redesign?**

Your spec satisfies all three.

### How to signal this clearly to judges (recommended slide / demo framing)

Use explicit language like:

> “Today, for the hackathon, the PTB verifier runs in the facilitator’s web app.
> In production, the *exact same verifier code* is shipped as a browser extension, moving the trust anchor to the buyer. No protocol changes required.”

That sentence alone demonstrates architectural maturity.

### Why this is “obvious but tedious”

* Writing an extension is engineering labor, not protocol design.
* Auditing an extension is process, not cryptography.
* Nothing about your design depends on *trusting* the extension—only on choosing where the verifier runs.

That distinction is exactly what strong protocol designs are supposed to make clear.

### One subtle but important advantage of your approach

Because:

* the verifier logic is deterministic,
* based on signed bytes,
* and constrained by a formal template,

…the extension can be:

* extremely small,
* easily auditable,
* and even implemented independently by third parties.

This is a much stronger story than “trust our wallet.”

### Bottom line

Yes:

* Judges will recognize the extension as the natural next step.
* They will not penalize you for not building it.
* They *will* reward you for showing that the design already anticipates it cleanly and correctly.

You are on exactly the right abstraction level.






